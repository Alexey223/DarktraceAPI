# PRD: Изучение и Парсинг Model Breach Алертов Darktrace API

**Версия:** 1.0
**Дата:** 2024-07-26

**Оглавление:**

1.  Введение
2.  Цели проекта
3.  Глоссарий
4.  Архитектура
5.  Технический стек
6.  Стиль гайд (Style Guide)
7.  Спецификация API
8.  Стратегия тестирования
9.  Схема данных
10. Процесс разработки
11. Лого принятых решений
12. Библиотека промптов
13. Правила для AI (Возможные будущие расширения)
14. Возможные следующие задачи

---

### 1. Введение

Данный документ (Product Requirements Document - PRD) описывает требования к проекту по изучению и парсингу "Model Breach" алертов с использованием Darktrace API. Проект направлен на создание инструмента для эффективного получения, обработки и анализа информации о нарушениях моделей безопасности, детектируемых системой Darktrace. Основной упор делается на полное документирование, следование лучшим практикам разработки и обеспечение возможностей для будущего расширения функционала, включая применение технологий искусственного интеллекта.

### 2. Цели проекта

*   **Изучение Darktrace API:** Глубокое понимание возможностей Darktrace API в части получения информации о "Model Breach" алертах.
*   **Разработка парсера:** Создание надежного и эффективного механизма для парсинга JSON-ответов от API, извлечения ключевой информации из алертов.
*   **Определение структуры данных:** Формализация структуры данных для хранения и обработки информации об алертах.
*   **Документирование:** Создание исчерпывающей документации по проекту, включая данный PRD, описание API, схемы данных и т.д.
*   **Определение потенциальных расширений:** Исследование возможностей для дальнейшего развития проекта, таких как интеграция с другими системами, визуализация данных, применение AI для углубленного анализа.

### 3. Глоссарий

| Термин             | Определение                                                                                                                               |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------- |
| **Model Breach Alert** | Уведомление, генерируемое системой Darktrace при выявлении поведения, отклоняющегося от построенной модели нормальной активности.     |
| **Darktrace API**  | Программный интерфейс приложения, предоставляемый Darktrace для взаимодействия с ее платформой и получения данных.                         |
| **API Key**        | Уникальный ключ (состоит из public и private token), используемый для аутентификации при запросах к Darktrace API.                                     |
| **JSON Payload**   | Данные, передаваемые в формате JSON (JavaScript Object Notation) в запросах к API или в ответах от API.                                   |
| **Парсинг**        | Процесс анализа строки или блока данных (например, JSON) для извлечения значимой информации и представления ее в структурированном виде. |
| **Прокси**         | Промежуточный сервер, который выступает посредником между клиентом и сервером API, например, для логирования или модификации запросов.     |
| **Endpoint**       | Конкретный URL-адрес в API, по которому можно получить доступ к определенному ресурсу или выполнить определенное действие.                  |
| **PBID**           | Policy Breach ID - уникальный идентификатор конкретного случая нарушения модели (Model Breach).                                             |
| **PID**            | Policy ID - уникальный идентификатор модели (правила), нарушение которой привело к алерту.                                                  |
| **UUID**           | Universally Unique Identifier - уникальный идентификатор модели, который остается постоянным в различных инсталляциях Darktrace.          |
| **DID**            | Device ID - уникальный идентификатор устройства, вовлеченного в Model Breach.                                                              |
| **Итерационная модель** | Подход к разработке, при котором проект разбивается на короткие циклы (итерации), каждый из которых включает планирование, разработку, тестирование и оценку. |
| **JSON Schema**    | Стандарт описания структуры JSON-документов, позволяющий валидировать их формат и определять типы данных.                               |
| **Логирование**    | Процесс записи информации о событиях, происходящих в системе (например, запросы к API, ошибки, результаты парсинга).                    |

### 4. Архитектура

#### 4.1. Схема архитектуры

```
+---------------------+      HTTPS Request       +---------------------+      JSON Response       +---------------------+      Parsed Data       +-----------------------+
|                     |  --------------------->  |                     |  <---------------------  |                     |  ------------------->  |                       |
|  Клиентский скрипт  |                          |  Darktrace API      |                          |  Модуль парсинга    |                          |  Система хранения/    |
|  (Python)           |  <---------------------  |  (Model Breaches   |  --------------------->  |  (Python)           |  <-------------------  |  Анализа данных       |
|                     |      API Key Auth        |   Endpoint)         |      Raw JSON Data       |                     |      Structured Data   |  (например, БД, CSV)  |
+---------------------+                          +---------------------+                          +---------------------+                          +-----------------------+
         ^                                                                                                                                                    |
         |                                                                                                                                                    |
         +------------------------------------------------------ Пользователь/Система -----------------------------------------------------------------------+
                                                               (Инициация, Конфигурация)
```

**Описание компонентов:**

*   **Клиентский скрипт (Python):** Отвечает за:
    *   Формирование запросов к Darktrace API (аутентификация с использованием API Key).
    *   Отправку запросов к эндпоинту `/modelbreaches`.
    *   Получение JSON-ответов от API.
    *   Передачу сырых JSON-данных в модуль парсинга.
    *   (Опционально) Взаимодействие с пользователем для ввода параметров (например, временной диапазон, фильтры).
*   **Darktrace API (Эндпоинт `/modelbreaches`):**
    *   Предоставляет доступ к данным о "Model Breach" алертах.
    *   Принимает запросы с различными параметрами для фильтрации и настройки вывода.
    *   Возвращает данные в формате JSON.
*   **Модуль парсинга (Python):**
    *   Принимает сырые JSON-данные от клиентского скрипта.
    *   Извлекает необходимую информацию из JSON-структуры согласно определенной схеме данных.
    *   Преобразует данные в удобный для дальнейшей обработки формат (например, список словарей, объекты).
    *   Обрабатывает возможные ошибки парсинга и отсутствующие поля.
*   **Система хранения/Анализа данных (Опционально, по необходимости):**
    *   Может быть реализована как простая запись в CSV-файл, JSON-файл, либо как более сложная система на базе реляционной или NoSQL базы данных.
    *   Предназначена для хранения структурированных данных об алертах для последующего анализа, создания отчетов или интеграции с другими системами.

#### 4.2. Описание выбранного подхода к реализации

*   **Язык программирования:** Python будет основным языком разработки благодаря его простоте, большому количеству библиотек для работы с API, JSON и обработки данных, а также его популярности в задачах анализа данных и ИИ.
*   **Взаимодействие с API:** Будет использоваться библиотека `requests` для HTTP-запросов. Аутентификация будет реализована согласно документации Darktrace API (вероятно, через заголовки запроса с public/private токенами и подписью запроса).
*   **Парсинг JSON:** Стандартная библиотека Python `json` будет использоваться для разбора JSON-ответов.
*   **Логирование:** Библиотека `logging` для записи информации о ходе выполнения, ошибках и важных событиях.
*   **Управление зависимостями:** `pip` и `requirements.txt` для управления внешними библиотеками.

#### 4.3. Примеры flow для получения и обработки API данных

**Flow 1: Получение всех новых Model Breach алертов за последний час**

1.  **Клиентский скрипт:**
    *   Определяет временной интервал (текущее время - 1 час, текущее время).
    *   Формирует GET-запрос к `https://[instance]/modelbreaches` с параметрами:
        *   `starttime`: (текущее время - 1 час) в миллисекундах.
        *   `endtime`: (текущее время) в миллисекундах.
        *   `includeacknowledged=false` (чтобы получать только необработанные алерты).
        *   `minimal=false` (для получения более детальной информации, если необходимо).
    *   Добавляет необходимые заголовки для аутентификации (API Key).
    *   Отправляет запрос.
2.  **Darktrace API:**
    *   Проверяет аутентификацию.
    *   Фильтрует Model Breach алерты по указанному временному диапазону и статусу (не подтвержденные).
    *   Возвращает JSON-ответ со списком алертов.
3.  **Клиентский скрипт:**
    *   Получает JSON-ответ.
    *   Проверяет статус-код ответа (200 OK).
    *   Передает JSON-данные в **Модуль парсинга**.
4.  **Модуль парсинга:**
    *   Разбирает JSON.
    *   Для каждого алерта извлекает ключевые поля (например, `pbid`, `time`, `model.name`, `model.uuid`, `score`, `device.hostname`, `device.ip`).
    *   Формирует список структурированных объектов/словарей.
5.  **Система хранения/Анализа (Пример: запись в CSV):**
    *   **Модуль парсинга** (или **Клиентский скрипт**) записывает структурированные данные в CSV-файл, где каждая строка – это алерт, а столбцы – это извлеченные поля.

### 5. Технический стек

| Технология/Инструмент | Назначение                                   | Обоснование выбора                                                                                                |
| --------------------- | -------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **Python 3.x**        | Основной язык программирования               | Простота, богатая стандартная библиотека, большое сообщество, множество библиотек для работы с API, JSON, данными.   |
| **Requests**          | Библиотека для HTTP-запросов                | Популярная, простая и мощная библиотека для взаимодействия с веб-сервисами.                                      |
| **json (Python)**     | Библиотека для работы с JSON                 | Встроенная в Python, эффективна для парсинга и генерации JSON.                                                    |
| **datetime (Python)** | Библиотека для работы с датами и временем     | Необходима для формирования временных параметров запросов к API и обработки временных меток в ответах.             |
| **logging (Python)**  | Библиотека для логирования                  | Стандартный инструмент для записи логов, гибкая настройка уровней логирования и обработчиков.                      |
| **CSV (Python)**      | Библиотека для работы с CSV файлами          | Простой способ хранения структурированных данных для начальных этапов и анализа.                                  |
| **Git**               | Система контроля версий                      | Стандарт для совместной разработки и отслеживания изменений в коде.                                                |
| **Markdown**          | Язык разметки для документации              | Легковесный и удобный для написания документации, включая данный PRD.                                            |
| **(Опционально) Docker** | Контейнеризация приложения                 | Для обеспечения переносимости и стандартизации окружения разработки/развертывания.                               |
| **(Опционально) JSON Schema** | Инструмент для валидации JSON       | Для формального описания и проверки структуры ожидаемых JSON-ответов от API и генерируемых данных.               |
| **(Опционально) PostgreSQL/SQLite** | Реляционная база данных       | Для более сложного хранения и анализа данных, если потребуется. SQLite для локальной разработки/прототипирования. |

### 6. Стиль гайд (Style Guide)

*   **PEP 8:** Строго следовать рекомендациям PEP 8 для форматирования кода Python. Использовать инструменты типа `flake8` или `black` для автоматической проверки и форматирования.
*   **Именование:**
    *   Переменные и функции: `lower_case_with_underscores` (snake_case).
    *   Классы: `CapWords` (PascalCase).
    *   Константы: `UPPER_CASE_WITH_UNDERSCORES`.
*   **Комментарии:**
    *   Писать осмысленные комментарии для сложных участков кода.
    *   Докстринги (docstrings) для всех модулей, классов, функций и методов в соответствии с PEP 257. Использовать формат reStructuredText или Google Style для докстрингов.
*   **Структура проекта:** Организовать код в логические модули и пакеты.
    *   `src/` или `project_name/`: для исходного кода.
    *   `tests/`: для тестов.
    *   `docs/`: для документации.
    *   `scripts/`: для вспомогательных скриптов.
    *   `data/`: (опционально, в `.gitignore`) для хранения временных или тестовых данных.
*   **Обработка ошибок:** Использовать исключения Python для обработки ошибок. Предоставлять понятные сообщения об ошибках.
*   **Логирование:** Использовать стандартный модуль `logging`. Настроить различные уровни логирования (DEBUG, INFO, WARNING, ERROR, CRITICAL).
*   **Конфигурация:** Хранить конфигурационные параметры (например, URL API, чувствительные данные) отдельно от кода (например, в переменных окружения или конфигурационных файлах `.env`, `.ini`, `.yaml`). Не коммитить чувствительные данные в репозиторий.
*   **Максимальная длина строки:** 100-120 символов для лучшей читаемости.
*   **Импорты:** Группировать импорты: стандартные библиотеки, сторонние библиотеки, локальные модули. Сортировать импорты внутри каждой группы по алфавиту.

### 7. Спецификация API

#### 7.1. Используемые API Endpoints

Основной эндпоинт для получения Model Breach алертов:

*   **URL:** `https://[instance_address]/modelbreaches`
    *   `[instance_address]` - это IP-адрес или FQDN вашего экземпляра Darktrace.
*   **Метод:** `GET`

Также может быть полезен эндпоинт `/metricdata` с параметром `breachtimes=true` для получения временных рядов данных с информацией о нарушениях моделей.

*   **URL:** `https://[instance_address]/metricdata`
*   **Метод:** `GET`

#### 7.2. Параметры запросов (для `/modelbreaches`)

| Параметр            | Тип      | Описание                                                                                                                                  | Пример                                   |
| ------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------- |
| `from`              | string   | Начальное время для выборки данных в формате `YYYY-MM-DD HH:MM:SS` или `YYYY-MM-DDTHH:MM:SS`.                                              | `2023-10-26T00:00:00`                    |
| `to`                | string   | Конечное время для выборки данных в формате `YYYY-MM-DD HH:MM:SS` или `YYYY-MM-DDTHH:MM:SS`.                                               | `2023-10-26T23:59:59`                    |
| `starttime`         | numeric  | Начальное время для выборки данных в миллисекундах (Unix timestamp * 1000).                                                               | `1698278400000`                          |
| `endtime`           | numeric  | Конечное время для выборки данных в миллисекундах (Unix timestamp * 1000).                                                                | `1698364799000`                          |
| `pbid`              | numeric  | Уникальный идентификатор нарушения модели (Policy Breach ID). Возвращает только указанный алерт.                                          | `12345`                                  |
| `pid`               | numeric  | Уникальный идентификатор модели (Policy ID). Возвращает алерты только для указанной модели.                                               | `678`                                    |
| `uuid`              | string   | Уникальный UUID модели. Возвращает алерты только для указанной модели.                                                                   | `80010119-6d7f-0000-0305-5e0000000420`   |
| `did`               | numeric  | Идентификатор устройства. Возвращает алерты, связанные с указанным устройством.                                                          | `101`                                    |
| `minscore`          | numeric  | Минимальный балл (score) алерта для включения в результат (значение от 0 до 1).                                                            | `0.75`                                   |
| `includeacknowledged` | boolean  | Включать ли в результат уже подтвержденные (acknowledged) алерты. По умолчанию `false` (или зависит от настроек экземпляра).            | `true`                                   |
| `minimal`           | boolean  | Уменьшить количество возвращаемых данных. `false` для получения более полной информации. По умолчанию `false` для программных запросов. | `false`                                  |
| `historicmodelonly` | boolean  | Возвращать только историческую версию деталей модели на момент нарушения.                                                                  | `true`                                   |
| `deviceattop`       | boolean  | Возвращать JSON-объект устройства на верхнем уровне ответа. По умолчанию `true` для программных запросов.                               | `true`                                   |
| `expandenums`       | boolean  | Разворачивать числовые перечислимые типы в их строковые представления.                                                                    | `true`                                   |
| `creationtime`      | boolean  | Если `true`, временные параметры (`from`/`to`, `starttime`/`endtime`) фильтруют по времени создания записи о нарушении, а не по времени активности. По умолчанию `false`. | `true`                                   |
| `responsedata`      | string   | Ограничивает возвращаемый JSON только указанным полем или объектом верхнего уровня (через запятую).                                       | `model,score,device`                     |
| `includesuppressed` | boolean  | Включать ли подавленные (suppressed) нарушения моделей. По умолчанию `false`.                                                             | `true`                                   |
| `saasfilter`        | string   | Фильтр для SaaS-нарушений (например, `SaaS::Office365*`). Можно использовать несколько раз. Требует `*` на конце.                       | `azure*`                                 |

**Аутентификация:**
Запросы к Darktrace API требуют аутентификации. Обычно это реализуется с помощью пары public/private токенов и вычисления HMAC-SHA256 подписи для каждого запроса. Детали необходимо уточнить в полной документации API.

*   `DTAPI-Token`: Публичный токен.
*   `DTAPI-Date`: Дата запроса в формате ISO 8601 (`YYYY-MM-DDTHH:MM:SSZ`).
*   `DTAPI-Signature`: Подпись запроса (`HMAC-SHA256(private_token, string_to_sign)`), где `string_to_sign` это конкатенация пути запроса (например, `/modelbreaches?pbid=123`), публичного токена и даты.

#### 7.3. Форматы ответов и примеры

**Пример запроса (GET):**
Предположим, `[instance]` это `your-darktrace.example.com`.

Получить все Model Breach алерты за определенный период с `pbid=287232`, включая только историческую информацию о модели:
`https://your-darktrace.example.com/modelbreaches?pbid=287232&historicmodelonly=true`

Или, альтернативно, используя путь:
`https://your-darktrace.example.com/modelbreaches/287232?historicmodelonly=true`

**Пример ответа (JSON - сокращенный, на основе документации):**

```json
{
  "creationTime": 1582213002000,
  "commentCount": 0,
  "pbid": 287232,
  "time": 1582212986000,
  "model": {
    "name": "Compromise::HTTP Beaconing to Rare Destination",
    "pid": 143,
    "phid": 123, // Исторический ID модели (policy history id)
    "uuid": "1a814475-5fef-499b-a467-4e2e68352cbb",
    "logic": {
      "data": [
        265
      ],
      "type": "componentList",
      "version": 1
    },
    "throttle": 3600,
    "description": "A device is making regular HTTP connections to a rare external location...",
    // ... другие поля модели
  },
  "triggeredComponents": [
    {
      "time": 1582212985000,
      "cbid": 305422, // component breach id
      "cid": 265,    // component id
      "size": 3,
      "threshold": 2,
      // ... другие поля компонента
      "metric": {
        "mlid": 1,
        "name": "externalconnections",
        "label": "External Connections"
      },
      "triggeredFilters": [
        {
          "cfid": 2087,
          "id": "A",
          "filterType": "Rare external endpoint",
          "arguments": {
            "value": 90
          },
          "comparatorType": ">",
          "trigger": {
            "value": "94"
          }
        }
        // ... другие фильтры
      ]
    }
  ],
  "score": 0.325,
  "percentscore": 33, // Score в процентах
  "device": { // Если deviceattop=true (по умолчанию для API)
    "did": 316,
    "ip": "10.0.56.12",
    "hostname": "Sarah Development",
    "typename": "desktop",
    "typelabel": "Desktop"
    // ... другие поля устройства
  }
}
```

**Ключевые поля в ответе:**

*   `pbid`: Policy Breach ID.
*   `time`: Время первого события, приведшего к нарушению (epoch ms).
*   `creationTime`: Время создания записи о нарушении (epoch ms).
*   `score`: Оценка серьезности нарушения (0-1).
*   `percentscore`: Оценка серьезности в процентах.
*   `model`: Объект с информацией о модели, вызвавшей алерт.
    *   `model.name`: Имя модели.
    *   `model.pid`: ID модели.
    *   `model.uuid`: UUID модели.
    *   `model.description`: Описание модели.
    *   `model.mitre`: (если применимо) Информация о соответствии MITRE ATT&CK.
*   `device` (или `triggeredComponents[].device` если `deviceattop=false`): Объект с информацией об устройстве.
    *   `device.did`: Device ID.
    *   `device.ip`: IP-адрес устройства.
    *   `device.hostname`: Имя хоста устройства.
    *   `device.typelabel`: Тип устройства.
*   `triggeredComponents`: Массив компонентов модели, которые были нарушены.
    *   `triggeredComponents[].metric.name`: Имя метрики компонента.
    *   `triggeredComponents[].triggeredFilters`: Фильтры, вызвавшие срабатывание компонента.

#### 7.4. Обработка ошибок

API Darktrace возвращает стандартные HTTP-коды ошибок:

*   **200 OK:** Запрос успешно выполнен.
*   **400 Bad Request:** Некорректные параметры запроса (например, неправильный формат даты, отсутствуют обязательные параметры). Тело ответа может содержать детали ошибки.
*   **401 Unauthorized:** Ошибка аутентификации (неверный API Key, неправильная подпись, истекший токен).
*   **403 Forbidden:** У пользователя нет прав на доступ к запрашиваемому ресурсу.
*   **404 Not Found:** Запрашиваемый ресурс (например, конкретный `pbid`) не найден.
*   **500 Internal Server Error:** Ошибка на стороне сервера Darktrace.
*   **503 Service Unavailable:** Сервис временно недоступен.

Клиентский скрипт должен:
1.  Проверять HTTP-статус код каждого ответа.
2.  В случае ошибок (4xx, 5xx) логировать полный текст ответа и код ошибки.
3.  Реализовать механизм повторных попыток (retry mechanism) с экспоненциальной задержкой для временных ошибок (например, 503 или при превышении лимитов запросов, если таковые имеются).
4.  Корректно обрабатывать ошибки JSON-парсинга, если ответ не является валидным JSON.

### 8. Стратегия тестирования

#### 8.1. Модульное тестирование (Unit Tests)

*   **Цель:** Проверить корректность работы отдельных функций и методов модуля парсинга.
*   **Объекты тестирования:**
    *   Функции, отвечающие за извлечение конкретных полей из JSON-объекта алерта (например, `get_pbid(alert_json)`, `get_score(alert_json)`, `get_device_ip(alert_json)`).
    *   Функции, преобразующие типы данных (например, конвертация timestamp в datetime-объект).
    *   Функции, обрабатывающие отсутствующие или некорректные поля в JSON.
    *   Функция основного парсера, которая агрегирует вызовы других функций и формирует итоговый структурированный объект алерта.
*   **Методы:**
    *   Использовать фреймворк для тестирования, например, `unittest` или `pytest` в Python.
    *   Подготовить набор разнообразных примеров JSON-ответов (валидных, с отсутствующими полями, с полями разных типов, с граничными значениями). Эти примеры можно взять из документации или реальных ответов API (после обезличивания).
    *   Для каждой функции написать тесты, проверяющие ее поведение на различных входных данных.
    *   Проверять, что извлекаются правильные значения и типы данных.
    *   Проверять корректную обработку `None` или значений по умолчанию для отсутствующих полей.

#### 8.2. Интеграционное тестирование

*   **Цель:** Проверить взаимодействие между клиентским скриптом, модулем парсинга и (если используется) системой хранения данных. Проверить взаимодействие с реальным (или mock) Darktrace API.
*   **Объекты тестирования:**
    *   Полный цикл: формирование запроса -> отправка запроса -> получение ответа -> парсинг ответа -> сохранение данных.
    *   Корректность формирования URL и заголовков запроса, включая аутентификацию.
    *   Обработка различных ответов от API (успешные, ошибки).
*   **Методы:**
    *   **С Mock API:** Создать mock-сервер, который имитирует поведение Darktrace API, возвращая предопределенные JSON-ответы на определенные запросы. Это позволяет тестировать без реальных вызовов к API, что ускоряет тесты и делает их независимыми от доступности API. Библиотеки типа `requests-mock` или `responses` для Python.
    *   **С реальным API (ограниченно):** Проводить ограниченное количество тестов с реальным API (например, на тестовом экземпляре Darktrace или с запросами, не влияющими на продуктивные данные и не превышающими лимиты). Эти тесты важны для проверки совместимости с актуальной версией API.
    *   Проверять, что данные корректно передаются между компонентами.
    *   Проверять, что ошибки API (например, 401, 404) корректно обрабатываются и логируются.
    *   Если используется система хранения, проверять, что данные правильно записываются и читаются.

#### 8.3. Тестирование обработки различных случаев алертов

*   **Цель:** Убедиться, что парсер корректно обрабатывает все ожидаемые вариации Model Breach алертов.
*   **Объекты тестирования:** Парсер и его способность обрабатывать:
    *   Алерты с разным количеством `triggeredComponents`.
    *   Алерты с опциональными полями (некоторые поля могут отсутствовать в зависимости от типа алерта или конфигурации).
    *   Алерты с различными типами моделей (`model.type`).
    *   Алерты, где информация об устройстве находится в `device` или `triggeredComponents[].device` (в зависимости от параметра `deviceattop`).
    *   Алерты с данными MITRE ATT&CK и без них.
*   **Методы:**
    *   Собрать или сгенерировать коллекцию JSON-примеров, покрывающих эти случаи.
    *   Использовать эти примеры в модульных тестах для модуля парсинга.

#### 8.4. Тестирование ошибок и крайних сценариев

*   **Цель:** Проверить устойчивость системы к непредвиденным ситуациям.
*   **Объекты тестирования:**
    *   Обработка невалидного JSON в ответе API.
    *   Обработка неожиданной структуры JSON (например, из-за изменений в API).
    *   Обработка сетевых ошибок при запросах к API (тайм-ауты, недоступность).
    *   Обработка ошибок аутентификации.
    *   Большие объемы данных (если API может вернуть очень много алертов).
*   **Методы:**
    *   Имитировать ошибки API (с помощью mock-сервера).
    *   Использовать невалидные JSON-строки в качестве входных данных для парсера.
    *   Тестировать поведение при отсутствии сети.
    *   Проверять логирование ошибок и корректное завершение работы или переход в безопасное состояние.

### 9. Схема данных

Определим примерную структуру данных для представления одного Model Breach алерта после парсинга. Это может быть Python-словарь или объект специального класса.

**Примерная структура (Python-like):**

```python
parsed_alert = {
    "pbid": 12345,  # int, Policy Breach ID
    "alert_time_utc": "2023-10-27T10:30:00Z",  # str, ISO 8601, время первого события (поле time)
    "creation_time_utc": "2023-10-27T10:30:05Z", # str, ISO 8601, время создания записи (поле creationTime)
    "score": 0.85,  # float, оценка (0-1)
    "percent_score": 85, # int, оценка в процентах
    "acknowledged": False, # boolean, подтвержден ли алерт (если поле есть)
    "acknowledged_by": None, # str, кем подтвержден (если есть)
    "acknowledged_time_utc": None, # str, ISO 8601, когда подтвержден (если есть)
    "model_id": 678,  # int, model.pid
    "model_uuid": "80010119-6d7f-0000-0305-5e0000000420",  # str, model.uuid
    "model_name": "Compromise::HTTP Beaconing to Rare Destination",  # str, model.name
    "model_description": "A device is making regular HTTP connections...", # str, model.description
    "model_category": "Critical", # str, model.category (если есть)
    "mitre_tactics": ["lateral-movement"], # list[str], model.mitre.tactics (если есть)
    "mitre_techniques": ["T1210"], # list[str], model.mitre.techniques (если есть)
    "device_id": 101,  # int, device.did
    "device_ip": "192.168.1.100",  # str, device.ip
    "device_hostname": "compromised-pc",  # str, device.hostname
    "device_type": "Desktop",  # str, device.typelabel
    "device_first_seen_utc": "2023-01-01T12:00:00Z", # str, ISO 8601 (если есть)
    "device_last_seen_utc": "2023-10-27T10:00:00Z", # str, ISO 8601 (если есть)
    "triggered_components_count": 1, # int, количество сработавших компонентов
    "components": [ # list[dict], информация о сработавших компонентах
        {
            "component_id": 265, # int, cid
            "component_breach_id": 305422, # int, cbid
            "component_time_utc": "2023-10-27T10:29:59Z", # str, ISO 8601
            "metric_name": "externalconnections", # str, metric.name
            "metric_label": "External Connections", # str, metric.label
            "size": 3, # int or float, size
            "threshold": 2, # int or float, threshold
            "filters": [ # list[dict], информация о сработавших фильтрах компонента
                {
                    "filter_id_ref": "A", # str, id (A, B, C...)
                    "filter_type": "Rare external endpoint", # str
                    "filter_arguments": {"value": 90}, # dict
                    "filter_comparator": ">", # str
                    "filter_trigger_value": "94" # str or numeric
                }
            ]
        }
    ],
    "breach_url": "https://[instance]/#modelbreach/12345", # str, (если includebreachurl=true и FQDN настроен)
    "raw_json": "{...}" # str, опционально, полный сырой JSON алерта для отладки или будущих нужд
}
```

**Описание полей и типов данных:**

*   Все временные метки рекомендуется хранить в UTC и представлять в формате ISO 8601 для однозначности. В API они приходят как epoch milliseconds.
*   Поля, которые могут отсутствовать в JSON-ответе, должны иметь значение по умолчанию (например, `None` для объектов/строк, `[]` для списков, `False` для boolean, `0` или `-1` для чисел, в зависимости от семантики).
*   Структура `components` и `filters` внутри них должна отражать иерархию из JSON-ответа.
*   Необходимо предусмотреть обработку случаев, когда `device` информация вложена в `triggeredComponents`.

Эта схема данных может быть формализована с использованием JSON Schema, если потребуется валидация или генерация кода на ее основе.

### 10. Процесс разработки

Будет использоваться итерационный подход, близкий к **Kanban** или **Scrum**, с короткими циклами разработки и регулярной демонстрацией результатов.

**Примерные этапы/итерации:**

1.  **Итерация 0: Подготовка и исследование**
    *   **Задачи:**
        *   Получение доступа к Darktrace API и тестовому экземпляру (если возможно).
        *   Детальное изучение документации по эндпоинту `/modelbreaches` и аутентификации.
        *   Настройка окружения разработки (Python, Git, необходимые библиотеки).
        *   Разработка базового скрипта для подключения к API и получения первых ответов (без сложного парсинга).
        *   Создание данного PRD (первая версия).
    *   **Критерии приемки:**
        *   Успешное подключение к API и получение JSON-ответа.
        *   Настроенное окружение.
        *   PRD согласован (начальная версия).

2.  **Итерация 1: Базовый парсинг и извлечение ключевых полей**
    *   **Задачи:**
        *   Реализация модуля парсинга для извлечения основных полей из JSON-ответа (pbid, time, score, model.name, device.ip/hostname).
        *   Создание простой структуры данных для хранения распарсенного алерта.
        *   Написание первых unit-тестов для парсера.
        *   Реализация простого вывода распарсенных данных (например, в консоль или CSV).
        *   Настройка базового логирования.
    *   **Критерии приемки:**
        *   Скрипт успешно получает, парсит и выводит ключевую информацию из Model Breach алертов.
        *   Unit-тесты покрывают базовые функции парсинга.
        *   Логируется основная информация о работе скрипта.

3.  **Итерация 2: Расширенный парсинг и обработка вложенных структур**
    *   **Задачи:**
        *   Реализация парсинга вложенных структур: `model` (детали модели, MITRE), `triggeredComponents` (включая метрики, фильтры).
        *   Обработка различных вариантов представления `device` (на верхнем уровне или внутри компонентов).
        *   Улучшение структуры данных для хранения полной информации.
        *   Написание дополнительных unit-тестов для новых функций парсинга.
        *   Обработка опциональных полей и установка значений по умолчанию.
    *   **Критерии приемки:**
        *   Парсер извлекает всю необходимую информацию из сложных JSON-структур.
        *   Корректно обрабатываются отсутствующие поля.
        *   Расширенные unit-тесты проходят.

4.  **Итерация 3: Обработка ошибок, интеграционное тестирование, конфигурация**
    *   **Задачи:**
        *   Реализация robustной обработки ошибок API (HTTP-ошибки, сетевые проблемы, ошибки аутентификации).
        *   Механизм повторных запросов (retry).
        *   Написание интеграционных тестов (с mock API и, возможно, с реальным API).
        *   Вынесение конфигурационных параметров (API URL, токены) во внешние файлы или переменные окружения.
        *   Улучшение логирования, добавление уровней детализации.
    *   **Критерии приемки:**
        *   Система устойчива к ошибкам API и сети.
        *   Интеграционные тесты проходят.
        *   Конфигурация отделена от кода.

5.  **Итерация 4: Рефакторинг, документирование кода, подготовка к использованию**
    *   **Задачи:**
        *   Рефакторинг кода для улучшения читаемости, производительности и соответствия style guide.
        *   Написание докстрингов для всех модулей, классов и функций.
        *   Создание README-файла с инструкциями по установке, настройке и использованию.
        *   Проведение финального тестирования.
        *   Обновление PRD.
    *   **Критерии приемки:**
        *   Код чистый, хорошо документирован.
        *   Проект готов к использованию.
        *   PRD актуализирован.

**Практики ревью кода (Code Review):**

*   Каждое значительное изменение кода (например, pull request в Git) должно проходить ревью как минимум одним другим разработчиком (если это команда) или саморевью (если разработчик один).
*   **Цели ревью:**
    *   Соответствие требованиям.
    *   Корректность логики.
    *   Отсутствие багов.
    *   Соответствие style guide.
    *   Читаемость и поддерживаемость кода.
    *   Качество тестов.
    *   Качество документации.
*   Использовать инструменты для совместной работы (например, комментарии в pull requests на GitHub/GitLab).

### 11. Лого принятых решений

| Дата       | Решение                                                                                                | Обоснование                                                                                                                                                                                                 | Принял        |
| ---------- | ------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------- |
| 2024-07-26 | Использовать Python в качестве основного языка разработки.                                                | Высокая продуктивность, наличие библиотек `requests` и `json`, применимость для анализа данных и AI.                                                                                                      | Gemini (AI)   |
| 2024-07-26 | Использовать эндпоинт `/modelbreaches` для получения алертов.                                           | Согласно документации Darktrace API, это основной эндпоинт для Model Breach алертов, предоставляющий наиболее полную информацию и гибкие параметры фильтрации.                                                   | Gemini (AI)   |
| 2024-07-26 | Хранить временные метки в UTC в формате ISO 8601 после парсинга.                                        | Обеспечивает однозначность и простоту работы с датами и временем в разных системах и часовых поясах.                                                                                                          | Gemini (AI)   |
| 2024-07-26 | Использовать PEP 8 и инструменты типа `flake8`/`black` для стиля кода.                                     | Обеспечение консистентности, читаемости и высокого качества кода.                                                                                                                                              | Gemini (AI)   |
| 2024-07-26 | Вынести конфигурацию (API-ключи, URL) из кода.                                                          | Безопасность (не коммитить секреты) и гибкость (легко менять конфигурацию для разных окружений).                                                                                                            | Gemini (AI)   |
| 2024-07-26 | Использовать итерационный подход к разработке (Kanban/Scrum-like).                                       | Позволяет гибко реагировать на изменения, получать обратную связь и поставлять работающий продукт по частям.                                                                                             | Gemini (AI)   |
| *TBD*      | Выбор конкретной СУБД для хранения данных (если потребуется что-то сложнее CSV/JSON).                   | *Будет определено на основе объема данных, требований к запросам и аналитике.*                                                                                                                             | *Команда проекта* |
| *TBD*      | Выбор конкретного фреймворка для AI/ML (если будет принято решение о реализации соответствующих задач). | *Будет определено на основе специфики задач AI (классификация, прогнозирование) и экспертизы команды.*                                                                                                         | *Команда проекта* |

*(Этот раздел будет пополняться по ходу проекта)*

### 12. Библиотека промптов (Примеры для Darktrace API)

Здесь "промпты" понимаются как готовые к использованию примеры запросов к API (URL с параметрами) для получения различных типов информации.

1.  **Получить все Model Breach алерты за последние 24 часа:**
    *   **Параметры:** `starttime` = (текущее время - 24 часа) в мс, `endtime` = (текущее время) в мс.
    *   **URL:** `https://[instance]/modelbreaches?starttime=<timestamp_24h_ago>&endtime=<current_timestamp>&minimal=false`

2.  **Получить Model Breach алерты с высоким скором (>= 0.9) за последнюю неделю:**
    *   **Параметры:** `starttime` = (тек. время - 7 дней) в мс, `endtime` = (тек. время) в мс, `minscore=0.9`.
    *   **URL:** `https://[instance]/modelbreaches?starttime=<timestamp_7d_ago>&endtime=<current_timestamp>&minscore=0.9&minimal=false`

3.  **Получить информацию о конкретном Model Breach алерте по его PBID:**
    *   **Параметры:** `pbid=12345`.
    *   **URL:** `https://[instance]/modelbreaches?pbid=12345&minimal=false&historicmodelonly=true` (или `https://[instance]/modelbreaches/12345?minimal=false&historicmodelonly=true`)

4.  **Получить все алерты для конкретной модели (по UUID) за последний месяц:**
    *   **Параметры:** `uuid=xxxx-xxxx...`, `starttime` = (тек. время - 1 месяц) в мс, `endtime` = (тек. время) в мс.
    *   **URL:** `https://[instance]/modelbreaches?uuid=xxxx-xxxx...&starttime=<timestamp_1m_ago>&endtime=<current_timestamp>&minimal=false`

5.  **Получить алерты для конкретного устройства (по DID), не подтвержденные:**
    *   **Параметры:** `did=101`, `includeacknowledged=false`.
    *   **URL:** `https://[instance]/modelbreaches?did=101&includeacknowledged=false&minimal=false`

6.  **Получить алерты, отфильтрованные по времени создания записи (а не времени активности):**
    *   **Параметры:** `starttime`, `endtime`, `creationtime=true`.
    *   **URL:** `https://[instance]/modelbreaches?starttime=<ts1>&endtime=<ts2>&creationtime=true&minimal=false`

7.  **Получить только имя модели, скор и информацию об устройстве для алертов:**
    *   **Параметры:** `responsedata=model.name,score,percentscore,device`.
    *   **URL:** `https://[instance]/modelbreaches?responsedata=model.name,score,percentscore,device&starttime=<ts1>&endtime=<ts2>`

Эти примеры могут быть использованы для тестирования, демонстрации или как основа для создания более сложных запросов в клиентском скрипте.

### 13. Правила для AI (Возможные будущие расширения)

Этот раздел рассматривает потенциальное применение технологий искусственного интеллекта (AI) для улучшения анализа Model Breach алертов Darktrace на основе данных, полученных через API.

#### 13.1. Потенциальные задачи для AI

На основе распарсенных данных об алертах, AI может помочь в решении следующих задач:

1.  **Интеллектуальная классификация и приоритизация алертов:**
    *   **Задача:** Автоматически классифицировать алерты по более гранулированным категориям, чем стандартные (например, "подозрение на фишинг", "аномальная передача данных", "попытка эксплуатации уязвимости") или предсказывать истинный уровень критичности, который может отличаться от `score` Darktrace.
    *   **Данные для обучения:** Исторические данные об алертах, их характеристики (тип модели, вовлеченные устройства, время, MITRE-теги) и метки от аналитиков (например, подтвержденный инцидент, ложное срабатывание, реальная угроза определенного типа).
    *   **Польза:** Снижение нагрузки на аналитиков, более быстрая реакция на действительно критичные инциденты.

2.  **Выявление взаимосвязей и корреляций между алертами:**
    *   **Задача:** Находить скрытые связи между, казалось бы, несвязанными алертами, которые могут указывать на сложную многоэтапную атаку. Например, несколько низкоуровневых алертов на разных устройствах могут быть частью одной кампании.
    *   **Данные для обучения:** Графы алертов, временные последовательности, характеристики вовлеченных сущностей (устройства, пользователи, внешние IP).
    *   **Польза:** Обнаружение сложных атак, которые могут быть пропущены при анализе отдельных алертов.

3.  **Прогнозирование новых типов алертов или аномального поведения:**
    *   **Задача:** На основе анализа текущих и исторических алертов, а также характеристик сети, предсказывать вероятность возникновения новых типов угроз или аномалий, еще не покрытых существующими моделями Darktrace.
    *   **Данные для обучения:** Временные ряды алертов, данные о сетевой топологии, информация об известных уязвимостях и угрозах (threat intelligence).
    *   **Польза:** Проактивное обнаружение угроз, адаптация защитных мер.

4.  **Автоматическое обогащение алертов контекстной информацией:**
    *   **Задача:** Дополнять алерты информацией из внешних источников (например, геолокация IP-адресов, репутация доменов, информация об уязвимостях ПО на устройстве) для лучшего понимания контекста и серьезности.
    *   **Польза:** Ускорение процесса расследования инцидентов.

5.  **Предложение рекомендаций по реагированию:**
    *   **Задача:** На основе типа алерта, его контекста и исторических данных о реагировании на подобные инциденты, предлагать аналитикам оптимальные шаги по реагированию.
    *   **Данные для обучения:** База знаний по инцидентам и ответным мерам, плейбуки.
    *   **Польза:** Стандартизация и ускорение реагирования на инциденты.

#### 13.2. Принципы использования AI и подходы к машинному обучению

*   **Классификация:**
    *   **Алгоритмы:** Support Vector Machines (SVM), Random Forest, Gradient Boosting (XGBoost, LightGBM), нейронные сети (например, многослойные перцептроны).
    *   **Применение:** Классификация алертов, определение уровня критичности.
*   **Кластеризация:**
    *   **Алгоритмы:** K-Means, DBSCAN, иерархическая кластеризация.
    *   **Применение:** Группировка схожих алертов, выявление аномальных кластеров.
*   **Анализ временных рядов:**
    *   **Алгоритмы:** ARIMA, Prophet, LSTM (рекуррентные нейронные сети).
    *   **Применение:** Прогнозирование количества или типов алертов.
*   **Обработка естественного языка (NLP):**
    *   **Алгоритмы:** TF-IDF, Word Embeddings (Word2Vec, GloVe, FastText), трансформеры (BERT, GPT).
    *   **Применение:** Анализ текстовых описаний моделей (`model.description`), комментариев к алертам (если будут собираться), автоматическое составление отчетов.
*   **Графовые алгоритмы / Графовые нейронные сети (GNN):**
    *   **Применение:** Выявление взаимосвязей между алертами, устройствами, пользователями.
*   **Обучение с подкреплением (Reinforcement Learning):**
    *   **Применение:** (Более сложная задача) Оптимизация стратегий реагирования.

#### 13.3. Этические соображения и ограничения

*   **Прозрачность и интерпретируемость:** Важно, чтобы решения, принимаемые AI, были по возможности объяснимы, особенно если они влияют на безопасность или приводят к блокировкам. Использовать методы интерпретации моделей (SHAP, LIME).
*   **Качество данных:** Эффективность AI сильно зависит от качества и полноты данных, на которых он обучается. "Мусор на входе – мусор на выходе". Необходима тщательная предварительная обработка и очистка данных.
*   **Смещение (Bias):** Обучающие данные могут содержать скрытые смещения, которые AI может усвоить и усилить, приводя к несправедливым или неточным результатам. Необходимо контролировать и смягчать смещения.
*   **Ложные срабатывания/пропуски:** AI-системы не идеальны и могут генерировать ложноположительные (false positives) и ложноотрицательные (false negatives) результаты. Важно настроить баланс между ними в зависимости от задачи и критичности ошибок.
*   **Безопасность AI-моделей:** Сами AI-модели могут быть подвержены атакам (например, состязательные атаки - adversarial attacks).
*   **Человеческий контроль:** AI должен рассматриваться как инструмент поддержки аналитиков, а не полная замена. Критически важные решения должны приниматься или подтверждаться человеком.
*   **Конфиденциальность данных:** При работе с данными об алертах необходимо соблюдать все требования по конфиденциальности и защите персональных данных.

### 14. Возможные следующие задачи (улучшение парсинга и расширение функционала)

После создания базового парсера и системы сбора данных об Model Breach алертах, проект может быть расширен в следующих направлениях:

1.  **Создание дашборда для визуализации алертов:**
    *   Разработка веб-интерфейса (например, с использованием Flask/Django + Plotly/Dash или специализированных инструментов типа Grafana) для отображения статистики по алертам, их распределения по времени, типам моделей, устройствам, уровню критичности.
    *   Интерактивные графики и таблицы для фильтрации и исследования данных.

2.  **Система уведомлений:**
    *   Настройка отправки уведомлений (например, по email, в Slack, Telegram) при появлении новых критичных алертов или при выполнении определенных условий (например, превышение порога по количеству алертов).

3.  **Интеграция с другими системами:**
    *   **SIEM-системы (Security Information and Event Management):** Отправка распарсенных и обогащенных алертов в SIEM для корреляции с другими событиями безопасности.
    *   **SOAR-платформы (Security Orchestration, Automation and Response):** Использование данных об алертах для запуска автоматизированных плейбуков реагирования.
    *   **Системы управления инцидентами (Ticketing Systems):** Автоматическое создание тикетов на основе критичных алертов.
    *   **Базы знаний / Threat Intelligence платформы:** Обогащение алертов данными из этих систем и, наоборот, пополнение этих систем информацией из Darktrace.

4.  **Расширенное логирование и аудит:**
    *   Более детальное логирование всех действий по получению и обработке алертов.
    *   Ведение аудита изменений статусов алертов (если будет реализована функция подтверждения/закрытия через API).

5.  **Управление конфигурацией парсера:**
    *   Возможность гибкой настройки через конфигурационный файл, какие поля извлекать, как их преобразовывать, по каким критериям фильтровать алерты на начальном этапе.

6.  **Разработка API для доступа к распарсенным данным:**
    *   Если распарсенные данные хранятся в централизованной базе, можно создать собственный API, который будет предоставлять эти данные другим внутренним инструментам или сервисам.

7.  **Долгосрочное хранение и анализ трендов:**
    *   Настройка долгосрочного хранения данных об алертах для анализа исторических трендов, выявления сезонности, оценки эффективности изменений в политиках безопасности.

8.  **Реализация функционала из раздела "Правила для AI":**
    *   Пошаговое внедрение AI-моделей для классификации, корреляции, прогнозирования и т.д.

Этот PRD должен служить живым документом и обновляться по мере развития проекта и появления новых требований. 